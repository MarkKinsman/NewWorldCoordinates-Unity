using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using UnityEngine.SceneManagement;

public class ObjectManager : MonoBehaviour
{

	[Tooltip ("Something to drop into a place on the selected plane. Currently unused." +
	"This will be replaced in time with a more robust object placement and selection functionality.")]
	public GameObject[] objectsToPlace;
	public float maxRayDistance = 30f;
	public LayerMask collisionLayerMask;

	//PRIVATE
	List<GameObject> objects;
	string filePath;
	public Transform[] transforms;
	Vector3 originalPosition;
	float originalRotation;
	string lastTargetName = "_noTarget";
	ActivityLog activityLog;
	enum Mode {standard, move, rotate, height};
	Mode mode = Mode.standard;

	// Use this for initialization
	void Start ()
	{
		activityLog = ActivityLog.Setup ();

		//create directory if it doesn't exist
		if (!Directory.Exists (Application.persistentDataPath + @"/Saves")) {
			Directory.CreateDirectory (Application.persistentDataPath + @"/Saves");
		}

		filePath = Application.persistentDataPath + @"/Saves/" + SceneManager.GetActiveScene ().name + "-" + gameObject.name;
		transforms = gameObject.GetComponentsInChildren<Transform> ();

		//Saves a file of the original location for resets
		originalPosition = transform.position;
		originalRotation = transform.eulerAngles.y;
		SaveFineTuning (filePath + "-Original");

		//Check for saved file and if it exists, use it to load previous positions. 
		if (File.Exists (filePath)) {
			activityLog.LogActivity ("Initializing with position data");
			LoadFineTuning ();
		} else {
			activityLog.LogActivity ("No FineTuning save file found for initialization.");
			Debug.LogWarning ("No FineTuning save file found for initialization.");
		}

	}

	//called by the follow script to pass the name of the last target found. 
	//Used in the file save so loaded fine tuning is for current location.
	public void UpdateLastTarget(string targetName){
		lastTargetName = targetName;
	}


	public void PlacePrefab ()
	{
		Vector3 center = new Vector3 (Screen.width / 2, Screen.height / 2, .5f);
		//pull piece from here:
		Ray ray = Camera.main.ScreenPointToRay (center);
		RaycastHit hit;

		//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
		//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
		if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayerMask)) {
            for (int i = 0; i < objectsToPlace.Length; i++)
            {
                GameObject placedThing = Instantiate<GameObject>(objectsToPlace[i], hit.point, Quaternion.identity, this.transform);
                objects.Add(placedThing);
            }

		} else {
			Debug.LogWarning ("Could not find plane. Did not place.");
			activityLog.LogActivity ("Could not find plane. Did not place.");
		}

	}

	//When does this apply? So confused. 
    public void PlaceObject()
    {
        Vector3 center = new Vector3(Screen.width / 2, Screen.height / 2, .5f);
        //pull piece from here:
        Ray ray = Camera.main.ScreenPointToRay(center);
        RaycastHit hit;

        //we'll try to hit one of the plane collider gameobjects that were generated by the plugin
        //effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
        if (Physics.Raycast(ray, out hit, maxRayDistance, collisionLayerMask))
        {
            for (int i = 0; i < objectsToPlace.Length; i++)
            {
                objectsToPlace[i].transform.position = hit.point;
                objectsToPlace[i].transform.rotation = Quaternion.identity;
            }
        }
        else
        {
            Debug.LogWarning("Could not find plane. Did not place.");
            activityLog.LogActivity("Could not find plane. Did not place.");
        }

    }

    //turns on the move script on all the placed objects
    //TODO: change this to be by selectoion
    public void MoveMode ()
	{
		MoveObject[] movers = gameObject.GetComponentsInChildren<MoveObject> ();
		RotateObject[] rotators = gameObject.GetComponentsInChildren<RotateObject> ();
		VerticalMove[] heighters = gameObject.GetComponentsInChildren<VerticalMove> ();
		if (mode == Mode.move) {
			mode = Mode.standard;
			for (int i = 0; i < movers.Length; i++) {
				movers [i].enabled = false;
			}
			return;
		}
		for (int i = 0; i < movers.Length; i++) {
			movers [i].enabled = true;
		}

		for (int i = 0; i < rotators.Length; i++) {
			rotators [i].enabled = false;
		}

		for (int i = 0; i < heighters.Length; i++) {
			heighters [i].enabled = false;
		}
		mode = Mode.move;
	}

	//turns on the rotate script on all the placed objects
	//TODO: change this to be by selection
	public void RotateMode ()
	{
		MoveObject[] movers = gameObject.GetComponentsInChildren<MoveObject> ();
		RotateObject[] rotators = gameObject.GetComponentsInChildren<RotateObject> ();
		VerticalMove[] heighters = gameObject.GetComponentsInChildren<VerticalMove> ();

		if (mode == Mode.rotate) {
			mode = Mode.standard;
			for (int i = 0; i < rotators.Length; i++) {
				rotators [i].enabled = false;
			}
			return;
		}

		for (int i = 0; i < movers.Length; i++) {
			movers [i].enabled = false;
		}
		for (int i = 0; i < rotators.Length; i++) {
			rotators [i].enabled = true;
		}
		for (int i = 0; i < heighters.Length; i++) {
			heighters [i].enabled = false;
		}
		mode = Mode.rotate;
	}

	//turns on the height script on all the placed objects
	//TODO: change this to be by selection
	public void HeightMode ()
	{
		MoveObject[] movers = gameObject.GetComponentsInChildren<MoveObject> ();
		RotateObject[] rotators = gameObject.GetComponentsInChildren<RotateObject> ();
		VerticalMove[] heighters = gameObject.GetComponentsInChildren<VerticalMove> ();

		if (mode == Mode.height) {
			mode = Mode.standard;
			for (int i = 0; i < heighters.Length; i++) {
				heighters [i].enabled = false;
			}
			return;
		}

		for (int i = 0; i < movers.Length; i++) {
			movers [i].enabled = false;
		}
		for (int i = 0; i < rotators.Length; i++) {
			rotators [i].enabled = false;
		}
		for (int i = 0; i < heighters.Length; i++) {
			heighters [i].enabled = true;
		}
		mode = Mode.height;
	}


	//overload method for below. Handles when not filepath is selected. The public version.
	/// <summary>
	/// Saves the fine tuning to a file. If no, file path string is defined, it will use the default filepath generated.
	/// </summary>
	public void SaveFineTuning ()
	{
		SaveFineTuning (filePath);
	}

	//overload to decide to pass last target name into file name
	public void SaveFineTuning(bool saveWithTargetName)
	{
		if (saveWithTargetName) {
			SaveFineTuning (filePath + lastTargetName);	
		} else {
			SaveFineTuning (filePath);
		}
	}

	//TODO: Decide if this is just the container, or if it's all the children.
	//Saves Positions. Note: this currently only works with pre-existing elements. Doesn't support objects being instantiated at runtime.
	void SaveFineTuning (string filePath)
	{
		activityLog.LogActivity ("Saving Fine Tuning");
		activityLog.LogActivity ("lskdjflskdjf");
		string[] positionStrings = new string[transforms.Length];
		for (int i = 0; i < transforms.Length; i++) {
			
			positionStrings [i] = 
				transforms [i].gameObject.name + ", " +
			transforms [i].localPosition.x.ToString () + ", " +
			transforms [i].localPosition.y.ToString () + ", " +
			transforms [i].localPosition.z.ToString () + ", rotation, " +
				transforms[i].localEulerAngles.y;
		}
		File.WriteAllLines (filePath, positionStrings);
		activityLog.LogActivity ("Saved Fine Tuning");
	}

	//overload method for below. Handles when not filepath is selected. The public version.
	/// <summary>
	/// Loads the fine tuning to a file. If no file path string is defined, it will use the default filepath generated.
	/// </summary>
	public void LoadFineTuning ()
	{
		LoadFineTuning (filePath);
	}

	//overload to decide to pass last target name into file name
	public void LoadFineTuning (bool loadWithTargetName)
	{
		if (loadWithTargetName) {
			LoadFineTuning (filePath + lastTargetName);
		} else {
			LoadFineTuning (filePath);
		}

	}

	public void LoadFineTuning (string filePath)
	{
		if (File.Exists (filePath)) {

			string[] positionStrings = File.ReadAllLines (filePath);
			string[][] coordinates = new string[positionStrings.Length][];

			//Check to make sure everything matches
			if (transforms.Length != positionStrings.Length) {
				Debug.LogError ("Number of objects in save file does not match current scene. Saving a new file and trying again.");
				activityLog.LogActivity("Number of objects in save file does not match current scene. Saving a new file and trying again.");
				ResetFineTuning ();
				SaveFineTuning (filePath);
				LoadFineTuning (filePath);
				return;
			}


			for (int i = 1; i < transforms.Length; i++) {
				coordinates [i] = positionStrings [i].Split (',');
				activityLog.LogActivity ("Loading postion data for " + coordinates [i] [0] + " into " + transforms [i]);

				//apply translation
				Vector3 newPosition = new Vector3 ();
				newPosition.x = float.Parse (coordinates [i] [1]);
				newPosition.y = float.Parse (coordinates [i] [2]);
				newPosition.z = float.Parse (coordinates [i] [3]);
				transforms [i].localPosition = newPosition;

				//apply rotation
				Vector3 newEuler = new Vector3 ();
				newEuler.x = transforms [i].localEulerAngles.x;
				newEuler.y = float.Parse (coordinates [i] [5]);
				newEuler.z = transforms [i].localEulerAngles.z;
				transforms [i].localEulerAngles = newEuler;
			}
		} else {
			Debug.LogWarning ("Could not load finetuning. File not found");
			activityLog.LogActivity ("Could not load finetuning. File not found");
		}
	}

	//reset positions, but does not save positions.
		public void ResetFineTuning ()
	{
		activityLog.LogActivity ("Resetting positions");
		LoadFineTuning (filePath + "-Original");
	}
}
